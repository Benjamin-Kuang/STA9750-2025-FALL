---
title: "Mini Project 2"
author: "Jin Kuang"
---

## Introduction of Dataset
We have several datasets. INCOME has the household income in specific areas and time. RENT contains the monthly rent of the household in specific areas and time. WAGES contains the wage of the wage, industry, and employment information in specific areas and time. INDUSTRY_CODES contains the code for each industry. POPULATION contains the population in specific areas and time. PERMITS contains the new housing area permitted in specific areas and time. HOUSEHOLDS contains the households number in specific areas and time.

We are now going to analyze some specific characteristics as indicated by the instructions posted by Professor Weylandt.

## Task 1: Data Import
```{r}
if(!dir.exists(file.path("data", "mp02"))){
    dir.create(file.path("data", "mp02"), showWarnings=FALSE, recursive=TRUE)
}

ensure_package <- function(pkg){
    pkg <- as.character(substitute(pkg))
    options(repos = c(CRAN = "https://cloud.r-project.org"))
    if(!require(pkg, character.only=TRUE, quietly=TRUE)) install.packages(pkg)
    stopifnot(require(pkg, character.only=TRUE, quietly=TRUE))
}

ensure_package(tidyverse)
ensure_package(glue)
ensure_package(readxl)
ensure_package(tidycensus)

get_acs_all_years <- function(variable, geography="cbsa",
                              start_year=2009, end_year=2023){
    fname <- glue("{variable}_{geography}_{start_year}_{end_year}.csv")
    fname <- file.path("data", "mp02", fname)
    
    if(!file.exists(fname)){
        YEARS <- seq(start_year, end_year)
        YEARS <- YEARS[YEARS != 2020] # Drop 2020 - No survey (covid)
        
        ALL_DATA <- map(YEARS, function(yy){
            tidycensus::get_acs(geography, variable, year=yy, survey="acs1") |>
                mutate(year=yy) |>
                select(-moe, -variable) |>
                rename(!!variable := estimate)
        }) |> bind_rows()
        
        write_csv(ALL_DATA, fname)
    }
    
    read_csv(fname, show_col_types=FALSE)
}

# Household income (12 month)
INCOME <- get_acs_all_years("B19013_001") |>
    rename(household_income = B19013_001)

# Monthly rent
RENT <- get_acs_all_years("B25064_001") |>
    rename(monthly_rent = B25064_001)

# Total population
POPULATION <- get_acs_all_years("B01003_001") |>
    rename(population = B01003_001)

# Total number of households
HOUSEHOLDS <- get_acs_all_years("B11001_001") |>
    rename(households = B11001_001)
```

```{r}
get_building_permits <- function(start_year = 2009, end_year = 2023){
    fname <- glue("housing_units_{start_year}_{end_year}.csv")
    fname <- file.path("data", "mp02", fname)
    
    if(!file.exists(fname)){
        HISTORICAL_YEARS <- seq(start_year, 2018)
        
        HISTORICAL_DATA <- map(HISTORICAL_YEARS, function(yy){
            historical_url <- glue("https://www.census.gov/construction/bps/txt/tb3u{yy}.txt")
                
            LINES <- readLines(historical_url)[-c(1:11)]

            CBSA_LINES <- str_detect(LINES, "^[[:digit:]]")
            CBSA <- as.integer(str_sub(LINES[CBSA_LINES], 5, 10))

            PERMIT_LINES <- str_detect(str_sub(LINES, 48, 53), "[[:digit:]]")
            PERMITS <- as.integer(str_sub(LINES[PERMIT_LINES], 48, 53))
            
            data_frame(CBSA = CBSA,
                       new_housing_units_permitted = PERMITS, 
                       year = yy)
        }) |> bind_rows()
        
        CURRENT_YEARS <- seq(2019, end_year)
        
        CURRENT_DATA <- map(CURRENT_YEARS, function(yy){
            current_url <- glue("https://www.census.gov/construction/bps/xls/msaannual_{yy}99.xls")
            
            temp <- tempfile()
            
            download.file(current_url, destfile = temp, mode="wb")
            
            fallback <- function(.f1, .f2){
                function(...){
                    tryCatch(.f1(...), 
                             error=function(e) .f2(...))
                }
            }
            
            reader <- fallback(read_xlsx, read_xls)
            
            reader(temp, skip=5) |>
                na.omit() |>
                select(CBSA, Total) |>
                mutate(year = yy) |>
                rename(new_housing_units_permitted = Total)
        }) |> bind_rows()
        
        ALL_DATA <- rbind(HISTORICAL_DATA, CURRENT_DATA)
        
        write_csv(ALL_DATA, fname)
        
    }
    
    read_csv(fname, show_col_types=FALSE)
}

PERMITS <- get_building_permits()
```

```{r}
ensure_package(httr2)
ensure_package(rvest)
get_bls_industry_codes <- function(){
    fname <- fname <- file.path("data", "mp02", "bls_industry_codes.csv")
    
    if(!file.exists(fname)){
    
        resp <- request("https://www.bls.gov") |> 
            req_url_path("cew", "classifications", "industry", "industry-titles.htm") |>
            req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
            req_error(is_error = \(resp) FALSE) |>
            req_perform()
        
        resp_check_status(resp)
        
        naics_table <- resp_body_html(resp) |>
            html_element("#naics_titles") |> 
            html_table() |>
            mutate(title = str_trim(str_remove(str_remove(`Industry Title`, Code), "NAICS"))) |>
            select(-`Industry Title`) |>
            mutate(depth = if_else(nchar(Code) <= 5, nchar(Code) - 1, NA)) |>
            filter(!is.na(depth))
        
        naics_table <- naics_table |> 
            filter(depth == 4) |> 
            rename(level4_title=title) |> 
            mutate(level1_code = str_sub(Code, end=2), 
                   level2_code = str_sub(Code, end=3), 
                   level3_code = str_sub(Code, end=4)) |>
            left_join(naics_table, join_by(level1_code == Code)) |>
            rename(level1_title=title) |>
            left_join(naics_table, join_by(level2_code == Code)) |>
            rename(level2_title=title) |>
            left_join(naics_table, join_by(level3_code == Code)) |>
            rename(level3_title=title) |>
            select(-starts_with("depth")) |>
            rename(level4_code = Code) |>
            select(level1_title, level2_title, level3_title, level4_title, 
                   level1_code,  level2_code,  level3_code,  level4_code)
    
        write_csv(naics_table, fname)
    }
    
    read_csv(fname, show_col_types=FALSE)
    
}

INDUSTRY_CODES <- get_bls_industry_codes()
```

```{r}
ensure_package(httr2)
ensure_package(rvest)
get_bls_qcew_annual_averages <- function(start_year=2009, end_year=2023){
    fname <- glue("bls_qcew_{start_year}_{end_year}.csv.gz")
    fname <- file.path("data", "mp02", fname)
    
    YEARS <- seq(start_year, end_year)
    YEARS <- YEARS[YEARS != 2020] # Drop Covid year to match ACS
    
    if(!file.exists(fname)){
        ALL_DATA <- map(YEARS, .progress=TRUE, possibly(function(yy){
            fname_inner <- file.path("data", "mp02", glue("{yy}_qcew_annual_singlefile.zip"))
            
            if(!file.exists(fname_inner)){
                request("https://www.bls.gov") |> 
                    req_url_path("cew", "data", "files", yy, "csv",
                                 glue("{yy}_annual_singlefile.zip")) |>
                    req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
                    req_retry(max_tries=5) |>
                    req_perform(fname_inner)
            }
            
            if(file.info(fname_inner)$size < 755e5){
                warning(sQuote(fname_inner), "appears corrupted. Please delete and retry this step.")
            }
            
            read_csv(fname_inner, 
                     show_col_types=FALSE) |> 
                mutate(YEAR = yy) |>
                select(area_fips, 
                       industry_code, 
                       annual_avg_emplvl, 
                       total_annual_wages, 
                       YEAR) |>
                filter(nchar(industry_code) <= 5, 
                       str_starts(area_fips, "C")) |>
                filter(str_detect(industry_code, "-", negate=TRUE)) |>
                mutate(FIPS = area_fips, 
                       INDUSTRY = as.integer(industry_code), 
                       EMPLOYMENT = as.integer(annual_avg_emplvl), 
                       TOTAL_WAGES = total_annual_wages) |>
                select(-area_fips, 
                       -industry_code, 
                       -annual_avg_emplvl, 
                       -total_annual_wages) |>
                # 10 is a special value: "all industries" , so omit
                filter(INDUSTRY != 10) |> 
                mutate(AVG_WAGE = TOTAL_WAGES / EMPLOYMENT)
        })) |> bind_rows()
        
        write_csv(ALL_DATA, fname)
    }
    
    ALL_DATA <- read_csv(fname, show_col_types=FALSE)
    
    ALL_DATA_YEARS <- unique(ALL_DATA$YEAR)
    
    YEARS_DIFF <- setdiff(YEARS, ALL_DATA_YEARS)
    
    if(length(YEARS_DIFF) > 0){
        stop("Download failed for the following years: ", YEARS_DIFF, 
             ". Please delete intermediate files and try again.")
    }
    
    ALL_DATA
}

WAGES <- get_bls_qcew_annual_averages()
```

  
## Extra Credit Opportunity #01: Relationship Diagram
![](Relationship Diagram.png)

## Task 2: Multi-Table Questions
### 1. Which CBSA (by name) permitted the largest number of new housing units in the decade from 2010 to 2019 (inclusive)?
```{r}
#| code-fold: true

library(dplyr)
library(DT)

PERMITS |>
  filter(year >= 2010, year <= 2019) |>
  group_by(CBSA) |>
  summarize(`New Housing Units Permitted` = sum(new_housing_units_permitted)) |>
  left_join(INCOME |> distinct(GEOID, NAME), join_by(CBSA == GEOID)) |>
  arrange(desc(`New Housing Units Permitted`)) |>
  datatable(options = list(searching = FALSE, info = FALSE)) 
```
Thus, Houston-Sugar Land-Baytown, TX Metro Area permitted the largest number of new housing units in the decade from 2010 to 2019 (inclusive).

### 2. In what year did Albuquerque, NM (CBSA Number 10740) permit the most new housing units?
```{r}
#| code-fold: true

PERMITS |>
  filter(CBSA == 10740, year != 2020, year != 2021) |>
  group_by(year) |>
  summarize(`New Housing Units Permitted` = sum(new_housing_units_permitted)) |>
  rename(`Year` = year) |>
  arrange(desc(`New Housing Units Permitted`)) |>
  datatable(options = list(searching = FALSE, info = FALSE))
```
Thus, Albuquerque, NM (CBSA Number 10740) permit the most new housing units in 2022, if excluding 
the Covid-19 period in 2020 and 2021.

### 3. Which state (not CBSA) had the highest average individual income in 2015?
```{r}
#| code-fold: true

INCOME |>
  filter(year == 2015) |>
  left_join(HOUSEHOLDS |> filter(year == 2015), join_by(GEOID == GEOID)) |> 
  mutate(`Total Income Per CBSA` = household_income * households,
         `Name` = str_extract(NAME.x, ", (.{2})", group=1)) |>
  select(GEOID, Name, `Total Income Per CBSA`) |>
  left_join(POPULATION |> filter(year == 2015), join_by(GEOID == GEOID)) |>
  rename(Population = population) |>
  select(GEOID, Name, `Total Income Per CBSA`, Population) |>
  mutate(`Average Individual Income` = `Total Income Per CBSA` / `Population`) |>
  arrange(desc(`Average Individual Income`)) |>
  datatable(options = list(searching = FALSE, info = FALSE))
```
From the table above, we can conclude that CA is the state that had the highest average individual income in 2015.

### 4. What is the last year in which the NYC CBSA had the most data scientists in the country?
```{r}
#| code-fold: true

t1 <- INCOME  |> mutate(std_cbsa = paste0("C", GEOID))
t2 <- WAGES |> mutate(std_cbsa = paste0(FIPS, "0"))
inner_join(t1, t2, join_by(std_cbsa == std_cbsa)) |>
  filter(INDUSTRY == 5182) |>
  group_by(YEAR, std_cbsa) |>
  summarize(`Employment Number` = sum(EMPLOYMENT)) |>
  arrange(YEAR, desc(`Employment Number`)) |>
  filter(`Employment Number` == first(`Employment Number`))|>
  filter(std_cbsa == "C35620") |>
  arrange(desc(`Employment Number`)) |>
  datatable(options = list(searching = FALSE, info = FALSE))
```
Thus, 2015 is the last year in which the NYC CBSA had the most data scientists in the country.

### 5. What fraction of total wages in the NYC CBSA was earned by people employed in the finance and insurance industries (NAICS code 52)? In what year did this fraction peak?
```{r}
#| code-fold: true

WAGES |>  
  filter(FIPS == "C3562") |>
  group_by(YEAR) |>
  summarize(
    `Total Wages` = sum(TOTAL_WAGES),
    `Finaance and Insurance Wages` = sum(ifelse(INDUSTRY == 52, TOTAL_WAGES, 0)),
    `Fraction` = `Finaance and Insurance Wages` / `Total Wages`) |>
  arrange(desc(`Fraction`)) |>
  datatable(options = list(searching = FALSE, info = FALSE))
```
Thus, the fractions of total wages in the NYC CBSA was earned by people employed in the finance and insurance industries are shown in the table above. This fraction peaks in 2014.


## Task 3: Initial Visualizations
### The relationship between monthly rent and average household income per CBSA in 2009.
```{r}
#| code-fold: true

library(ggplot2)

Q1 <- INCOME |> 
  filter(year == 2009) |>
  inner_join(RENT |> filter(year == 2009), join_by(GEOID == GEOID)) |>
  select(NAME.x, household_income, monthly_rent)

ggplot(Q1, aes(x = household_income, y = monthly_rent)) +
  # Make points slightly transparent so plot is less busy
  geom_point(alpha=0.3) + 
  xlab("Average Household Income (USD)") + 
  ylab("Monthly Rent (US Dollars)") + 
  labs(title="The Relationship Between Monthly Rent And Average Household Income In 2009") + 
  stat_smooth(se=FALSE, 
              color="red4") +
  # Format y axis as dollars
  scale_y_continuous(labels=scales::dollar) +
  scale_x_continuous(labels=scales::dollar) +
  theme_bw()
```

### The relationship between total employment and total employment in the health care and social services sector (NAICS 62) across different CBSAs. 
```{r}
#| code-fold: true

t1 <- WAGES |>
  group_by(YEAR, FIPS) |>
  summarize(total_employment = sum(EMPLOYMENT))

t2 <- WAGES |>
  filter(INDUSTRY == 62) |>
  group_by(YEAR, FIPS) |>
  summarize(health_and_social = sum(EMPLOYMENT))

t3 <- inner_join(t1, t2, join_by(YEAR == YEAR,
                                 FIPS ==FIPS)) |>
  mutate(fraction = health_and_social / total_employment)

ggplot(t3, aes(x = YEAR, y = fraction, group = FIPS)) +
  geom_line(alpha=0.3) + 
  theme_bw() + 
  xlab("Year") + 
  ylab("Fraction of Employment In Health Care And Social Services") + 
  labs(title="Total Employment vs Employment In Health Care and Social Services") 
```

### The evolution of average household size over time. Use different lines to represent different CBSAs.
Note that Extra Credit Opportunity #02 is also included.
```{r}
#| code-fold: true

library(gghighlight)

Q3 <- POPULATION |>
  inner_join(HOUSEHOLDS, join_by(GEOID == GEOID,
                                 year == year)) |>
  mutate(average = population / households)

ggplot(Q3, aes(x=year, 
                    y=average, 
                    group=GEOID,
                    color=case_when(GEOID == 35620 ~ "New York",
                                    GEOID == 31080 ~ "Los Angeles"))) +
  geom_line() +
  scale_color_manual(values = c("New York" = "blue", "Los Angeles" = "red"),
                     name = "Highlight") +
  gghighlight(GEOID %in% c(35620, 31080), 
              use_direct_label = FALSE, 
              unhighlighted_params = list(alpha=0.3)) +
  theme_bw() + 
  theme(legend.position="bottom") + 
  xlab("Year") + 
  ylab("Average Household Size") + 
  labs(title="The Evolution Of Average Household Size Over Time")
```

## Task 4: Rent Burden
### Pick a single Metropolitan Area and see how rent burden has changed over time
I picked the rent-to-income ratio. My baseline is the average rent-to-income ratio in the first year of my study, which is 2009. I standardized my metric by dividing by the baseline value so that values can be interpreted as “k times baseline”.
```{r}
#| code-fold: true

standard_ratio <- INCOME |>
  inner_join(RENT, join_by(GEOID == GEOID, year == year, NAME == NAME)) |>
  mutate(rent_to_income = (12 * monthly_rent) / household_income)

baseline <- standard_ratio |>
  filter(year == 2009) |>
  summarize(baseline = mean(rent_to_income)) 

standard_ratio <- standard_ratio |>
  mutate(standardized_metric = rent_to_income / baseline[[1]])

standard_ratio |>
  filter(GEOID == 35620) |>
  arrange(year) |>
  select(NAME, year, rent_to_income, standardized_metric) |>
  rename(Year = year,
         `Rent to Income Ratio` = rent_to_income,
         `Standardized Metric` = standardized_metric) |>
  datatable(options = list(searching = FALSE, info = FALSE))
```

### Highlight the Metro Areas highest and lowest with the highest and lowest rent burden
```{r}
#| code-fold: true

standard_ratio |>
  filter(standardized_metric == max(standardized_metric) |
         standardized_metric == min(standardized_metric)) |>
  select(NAME, year, rent_to_income, standardized_metric) |>
  rename(Year = year,
         `Rent to Income Ratio` = rent_to_income,
         `Standardized Metric` = standardized_metric) |>
  datatable(options = list(searching = FALSE, info = FALSE))
```
Thus, the Metro Areas with the highest and lowest rent burden are Bismarck, ND Metro Area and Mayagüez, PR Metro Area, respectively.

## Task 5: Housing Growth
### Instantaneous Measure
This is the table for instantaneous measure.
```{r}
#| code-fold: true

table1 <- PERMITS |>
  inner_join(POPULATION, join_by(CBSA == GEOID, year == year)) |>
  mutate(instantaneous = new_housing_units_permitted / population)

baseline <- table1 |>
  filter(year == 2009) |>
  summarize(baseline = mean(instantaneous)) 

table1 <- table1 |>
  mutate(standardized_instantaneous = instantaneous / baseline[[1]])

table1 |>
  filter(standardized_instantaneous == max(standardized_instantaneous) |
         standardized_instantaneous == min(standardized_instantaneous)) |>
  select(CBSA, year, NAME, instantaneous, standardized_instantaneous) |>
  rename(Year = year,
         `Instantaneous Measure` = instantaneous,
         `Standardized Instantaneous Measure` = standardized_instantaneous) |>
  datatable(options = list(searching = FALSE, info = FALSE))
```
Thus, Salisbury, MD Metro Area and Danville, IL Metro Area have the highest and the lowest standardized instantaneous measure, respectively.

### Rate-based Measure
This is the table for rate-based measure.
```{r}
#| code-fold: true

table2 <- PERMITS |>
  inner_join(POPULATION, join_by(CBSA == GEOID, year == year)) |>
  mutate(rate_based = new_housing_units_permitted / (population - lag(population, n = 5)))

baseline <- table2 |>
  filter(year == 2009) |>
  summarize(baseline = mean(rate_based, na.rm = TRUE)) 

table2 <- table2 |>
  mutate(standardized_rate_based = rate_based / baseline[[1]])

table2 |>
  slice(-1:-5) |>
  filter(standardized_rate_based == max(standardized_rate_based) |
         standardized_rate_based == min(standardized_rate_based)) |>
  select(CBSA, year, NAME, rate_based, standardized_rate_based) |>
  rename(Year = year,
         `Rate-based Measure` = rate_based,
         `Standardized Rate-based Measure` = standardized_rate_based) |>
  datatable(options = list(searching = FALSE, info = FALSE))
```
Thus, Spartanburg, SC Metro Area and Richmond, VA Metro Area have the highest and the lowest standardized rate-based measure, respectively.

### Composite Score
This is the table for the composite score.
```{r}
#| code-fold: true

table3 <- table1 |>
  inner_join(table2, join_by(CBSA == CBSA, 
                             year == year,
                             NAME == NAME)) |>
  select(CBSA, year, NAME, standardized_instantaneous, standardized_rate_based) |>
  mutate(composite = rowMeans(cbind(standardized_instantaneous, standardized_rate_based),
                              na.rm = TRUE))

baseline <- table3 |>
  filter(year == 2009) |>
  summarize(baseline = mean(composite)) 

table3 <- table3 |>
  mutate(standardized_composite = composite / baseline[[1]])

table3 |>
  filter(standardized_composite == max(standardized_composite) |
         standardized_composite == min(standardized_composite)) |>
  select(CBSA, year, NAME, composite, standardized_composite) |>
  rename(Year = year,
         `Composite Score` = composite,
         `Standardized Composite Score` = standardized_composite) |>
  datatable(options = list(searching = FALSE, info = FALSE))
```
Thus, Spartanburg, SC Metro Area and Richmond, VA Metro Area have the highest and the lowest standardized composite score, respectively.

## Task 6: Visualization
### First Plot
```{r}
#| code-fold: true

Vis <- table1 |>
  inner_join(table2, join_by(CBSA == CBSA, 
                             year == year,
                             NAME == NAME)) |>
  inner_join(standard_ratio, join_by(year == year,
                             NAME == NAME)) |>
  group_by(CBSA, NAME) |>
  summarize(
    high_rent = mean(standardized_metric[year %in% 2009:2014]),
    decrease_rent = last(standardized_metric) - first(standardized_metric),
    population_growth = last(population.x) - first(population.x),
    housing_growth = mean(standardized_instantaneous)) |>
  filter(high_rent > mean(high_rent, na.rm = TRUE),
         decrease_rent < 0,
         population_growth > 0,
         housing_growth > mean(housing_growth))

ggplot(standard_ratio |> filter(NAME %in% Vis$NAME),
       aes(x = year, y = standardized_metric, color = NAME)) +
  geom_line(size = 1) +
  theme_bw() + 
  theme(legend.position="bottom",
        legend.text = element_text(size = 5)) + 
  xlab("Year") + 
  ylab("Standardized Rent To Income Ratio") + 
  labs(title="The Most “YIMBY” CBSAs",
       color = NULL)
```

### Second Plot
```{r}
#| code-fold: true

ggplot(table3 |> filter(NAME %in% Vis$NAME),
       aes(x = year, y = standardized_instantaneous, color = NAME)) +
  geom_line(size = 1) +
  theme_bw() + 
  theme(legend.position="bottom",
        legend.text = element_text(size = 5)) + 
  xlab("Year") + 
  ylab("Standardized Instantaneous Measure") + 
  labs(title="The Most “YIMBY” CBSAs",
       color = NULL)
```
The most “YIMBY” CBSAs are Baltimore-Columbia-Towson, MD Metro Area; Bend-Redmond, OR Metro Area;Cape Girardeau, MO-IL Metro Area; Elizabethtown, KY Metro Area; Gulfport-Biloxi, MS Metro Area; Hinesville, GA Metro Area; Indianapolis-Carmel-Anderson, IN Metro Area; Madera, CA Metro Area; Naples-Immokalee-Marco Island, FL Metro Area; Providence-Warwick, RI-MA Metro Area; Salisbury, MD Metro Area; Stockton-Lodi, CA Metro Area; and Wenatchee, WA Metro Area. Because they had relatively high rent burden in the early part of the study period (presumably "above its average"); had a decrease in rent burden over the study period; had population growth over the study period; and had above-average housing growth during the study period.

Among all of the “YIMBY” CBSAs, Salisbury, MD Metro Area is the best, since it shows clear upward trend in the second plot.

### Task 7: Policy Brief
```{r, results = "hide"}
#| code-fold: true

t1 <- INCOME |> mutate(std_cbsa = paste0("C", GEOID))
t2 <- WAGES |> mutate(std_cbsa = paste0(FIPS, "0"))
Commercial_and_institutional_construction <- inner_join(t1, t2, join_by(std_cbsa == std_cbsa)) |>
  filter(std_cbsa == "C35620",
         INDUSTRY == 23622,
         year == 2023) |>
  summarize(`Total employment for commercial and institutional building construction` = sum(EMPLOYMENT)) |>
  datatable(options = list(searching = FALSE, info = FALSE))

Commercial_and_institutional_construction

Heavy_and_civil_engineering_construction <- inner_join(t1, t2, join_by(std_cbsa == std_cbsa)) |>
  filter(std_cbsa == "C12580",
         INDUSTRY == 237,
         year == 2023) |>
  summarize(`Total employment for heavy and civil engineering construction` = sum(EMPLOYMENT)) |>
  datatable(options = list(searching = FALSE, info = FALSE))

Heavy_and_civil_engineering_construction
```

A primary sponsor from Baltimore-Columbia-Towson, MD Metro Area and a co-sponsor from New York, together they will sponsor my bill. They need this bills, especially the co-sponsor from New York, because they can establish a more-YIMBY set of housing policies. In 2023, Baltimore-Columbia-Towson, MD Metro Area has 120,114 heavy and civil engineering construction workers; in 2023, NYC has 444,814 commercial and institutional building construction workers. These numbers are definitely non-trivial. My policy will be favorable for the interest groups because those workers in Baltimore-Columbia-Towson, MD Metro Area may spend less on rent based on the previous reasoning of YIMBY success; for NYC, if the rent goes down, the income for commercial and institutional building construction workers would arise because the budget for the commercial and institutional building becomes more.

Metrics the government can use to identify ‘good’ (high-YIMBY) cities and to target funding appropriately could be "standardized_metric", "standardized_instantaneous", "standardized_rate_based", and "composite". "standardized_metric" is calculated by using the average rent-to-income ratio in the first year of my study, which is 2009, and divided by baseline value. "standardized_instantaneous" is concluded by "new_housing_units_permitted / population / baseline value". "standardized_rate_based" utilized lag function for the first five years of my study, specifically, "new_housing_units_permitted / (population - lag(population, n = 5) / baseline value". "composite" is simply by taking the average of the previous two value.

(Extra Credit Opportunity #03)
The sponsors' hometown needs this bill because young people care about affordability of the household. If young people could not affor the house or living places, they definitely would not want to come to this city. Therefore, I designed a variable called "affordability". It is calculated by household_income divided by (12 * monthly_rent). Therefore, larger value means the house in that area is more affordable, which suggests it is more appeal to young people.

```{r}
#| code-fold: true

affordability <- INCOME |> 
  filter(year == 2023) |>
  inner_join(RENT |> filter(year == 2023), join_by(GEOID == GEOID)) |>
  select(NAME.x, household_income, monthly_rent) |>
  mutate(household_income / (12 * monthly_rent))
```

## Conclusion
By now, we have completed all boded Tasks and all three Extra Credit Opportunity.





